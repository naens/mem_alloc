#+TITLE: Generalized Fibonacci Memory Allocator

* Introduction
So, I've made this new little project, which initially had to be just
a module to be used by other applications, but it turned out to be
slightly more complex than expected.  So I decided to dedicate a whole
repository to this memory allocator.

* Overview
This is a generalized Fibonacci memory allocator.  That means that
there are multiple free lists grouped in an array and ordered by
sizes, which follow a generalized Fibonacci sequence.  In this case
it's 1, 2, 3, 4, 5, 7, 10 ,14, 19, 26, 36..., and so on where a_n =
a_{n-1} + a_{n-4}.  The sequence does not have to begin from the first
element.

It's a buddy-based allocator.  Each item has a buddy, and two buddies
can be combined into a single item.

* Data Structures
** Array
The top data structure is a dynamic array.  When it's first allocated,
it's small, because not every program needs to allocate a lot of
memory.  But because the user might want more memory, the array is
copied into a larger array, and the original array is freed.

To allocate and deallocate data I use the functions provided by the
OS.  The allocator asks as little as possible, because you might never
know if the allocator of the OS is good enough.  For this reason the
size of the memory allocated from the OS increases each times.  It
follows the generalized Fibonacci sequence: each item has to be at
least a the size of the block multiplied by the next number of the
sequence, relative to the size of th last allocation.

The array allocates memory for itself.  The first allocation is
designed so that if freed, it can be inserted into the array.  When
the array needs to be increased, a new allocation is made the array is
copied inside of it and the previous allocation is released.

By doing this kind of allocation we can have a really simple Operating
System allocator: it does not have to be able to free the memory in a
random order: every allocation is reused by the allocator and so, the
memory can be freed in any order: the allocation order, the opposite
order, or all at once, in case we have a big chunk of memory that we
have to use for our programs.

So here is the details that describe the way I made the calculations
for the 64-bit Operating System (for other sizes it's similar but with
different numbers, you can find them in the /defines/ of the file
~mem.c~.

| Index | Size | Capacity | Array bytes | Area bytes |
|-------+------+----------+-------------+------------|
|     0 |    3 |        2 |          32 |         16 |
|     1 |    4 |        2 |          32 |         24 |
|     2 |    5 |        4 |          64 |         32 |
|     3 |    7 |        4 |          64 |         48 |
|     4 |   10 |        8 |         128 |         72 |
|     5 |   14 |        8 |         128 |        104 |
|     6 |   19 |        8 |         128 |        144 |
|     7 |   26 |        8 |         128 |        200 |
|     8 |   36 |       16 |         256 |        280 |
|     9 |   50 |       16 |         256 |        329 |

The size of the block is 8 for every system.  It's because the header
of the item has to contain 3 flags.

The size begins at 3, not at 1.  The reason is so that an item be able
to hold the header, the next pointer and the previous pointer.  It's
not the same for 32-bits and 16-bits.  For example, on 16-bits an item of
1 block is big enough to contain the three pointer-sized fields.

We increase the capacity just before the array size reaches it.  This
allows us to always have the sizes for every index we might need.

The array size in bytes is the capacity multiplied by 16 (a cell
contains two fields of 8 bytes).

The size of the area that is contained in the items of a free list is
calculated by multiplying the size (the generalized Fibonacci sequence
number) by 8, because blocks are 8 bytes, and by subtracting 8, which
is the size of the header in bytes.

We are looking for a free list that can contain the array.  As we can
see it happens at index 6 and after: 144 is greater than 128.  It's
also the case for 200 and 128, 280 and 256 and so on.  Actually the
difference increases, which allows us to stop worrying about the issue
after the initial initialization.


** Cells
Another data structure is the cell.  A cell contains the size, which
is a number from the generalized Fibonacci sequence and a pointer to a
free list of that size.  The cells will be in the array, and they will
be ordered according to the sequence.
#+BEGIN_SRC c
struct cell {
    uintptr_t size;
    void *items;
};
#+END_SRC

The array has a size field, which represents how many usable cells it
contains.  When the size of the array is increased, the cells are
filled with corresponding numbers from the sequence.
#+BEGIN_SRC c
struct array {
    struct cell *data;
    unsigned int size;
    unsigned int capacity;
};
#+END_SRC

All items in a free list, which come from one cell have the same size.
This way it's easy to allocate a certain amount of blocks: just go
through the array and find the cell which contains the size bigger or
equal than requested.

So, here is an example of an array, in order to visualize:
| Index | cell->size | cell->data       |
|-------+------------+------------------|
|     0 |          3 | null             |
|     1 |          4 | item->null       |
|     2 |          5 | null             |
|     3 |          7 | item->item->null |
|-------+------------+------------------|


** Blocks
The numbers in the generalized Fibonacci sequence correspond to the
number of blocks contained in every item of the free list of that
size.  The blocks are always 8 bytes.

** Items
Free lists are doubly linked lists, where each node represents a
memory area that can be returned.  In my implementation I call nodes
items.  Each such item has a header, which contains the total size of
the item in blocks and 3 bits: ~lr_bit~, ~inh_bit~, and ~in_use~ bit.

When the item is in a free list, its ~in_use_~ bit is 0, but when it's
used by the user, the ~in_use~ bit is set to 1.

The ~lr_bit~ tells whether the item is a right buddy or a left buddy.
Items can be split into a left buddy and a right buddy, and the left
and the right buddy can be merged together.

The ~inh_bit~ comes from the parent item.  It is used in order to
restore the ~lr_bit~ of the parent when two buddies are merged.  When
the buddies are split, the left buddy inherits the ~lr_bit~ of the
parent, and the right buddy inherits the ~inh_bit~ of the parent.  So,
when buddies are combined, the parent can restore its ~lr_bit~ and its
~inh_bit~.

When not in use, the area of the item after the header is used to hold
the previous and the next pointers for the doubly linked list.

* Functions
So now I'll explain how the main functions work, namely allocation and
deallocation.  But before that I would like to mention two other of
the main functions: ~mem_init~ and ~mem_finalize~.  In my
implementation they are really simple, they initialize and free the
data.

The initialization function sets the first items of the array, so from
these four items it can calculate all the other items.

The finalization function returns all allocated elements to the OS.
In order to track them every allocated element is made into a linked
list node, where the first bytes hold a pointer to the next.  Every
new element is prepended, make it a singly linked list.  So when
freeing the list all I have to do is follow this list and free the
elements one by one.

** Allocation
Now, this is how the allocation works: first we look for an element in
the free list which has enough blocks to hold the number of bytes we
requested.  If we have not found, we ask from the OS.  Each time we
ask at least the next number: we don't ask for smaller numbers or the
same number multiple times: it's in order to keep the number of the OS
allocations as small as possible.

Then, when we have something which can hold our amount of bytes, we
should try to split the item: perhaps it's too big, so we have to take
the smallest possible in order to hold our bytes.  We split it as I
described earlier, using the buddy system.

** Deallocation
And this is how deallocation works.  First, we are given an area, by
which we find the header of the item.  It is not difficult because the
header is of constant size.  Then from the header we retrieve the size
of the block, using which we can find the right index in the array.
Before inserting, we mark the item as not in use.

After we insert the deallocated item into the array, we have to merge
free buddies if we find some.  This is done using the ~coalesce~
function.

The ~coalesce~ function is a loop: it looks if there is a free buddy
for the item, if so, then merges them.  Then continues by looking for
a buddy for the new merged item and so on, until it finds a buddy that
is in use, which it will find, since the buddy of the root is a fake
buddy which is empty and which was marked as in use.

* Tests
In order to test the memory allocator I have created a number of
tests.  These tests are located in the ~mem_test.c~ file.  There are
some tests that test a specific feature, and one test that generates
random sequence of action based on the parameters.

* Portability
In my implementation I tried to isolate parameters which could be
modified.  For example, if the size of the pointers changes, then the
number of bytes in the header changes because it's the same as the
size of a pointer.  Also the are changes, because it has to contain
two pointers.  But the number of bytes in a block doesn't change,
which it so that there are different configurations for different
sizes of the pointer.

So here is how we get the minimal sizes in the array.  In a 64-bit
system, the array starts at index 0 which contains a free list of 3
blocks.  But for 32-bytes, it can be 2 blocks, and 16-bytes can start
at 1 block.

In order to implement these differences I created different defines,
one set for each of the pointer sizes.  Here is an example for the
64-bit system:
#+BEGIN_SRC c
/* 64-bit OS */
#if defined(__x86_64__)
#define MIN_SIZE 3
#define SIZE_1 4
#define SIZE_2 5
#define SIZE_3 7
#+END_SRC

Then it continues similarly for the other:

#+BEGIN_SRC c
/* 32-bit OS */
#elif defined(__386__) || defined(__i386__) || defined(__DJGPP__)
#define MIN_SIZE 2
#define SIZE_1 3
#define SIZE_2 4
#define SIZE_3 5

/* 16-bit OS */
#elif defined(__I86__) || defined(__86__)
#define MIN_SIZE 1
#define SIZE_1 2
#define SIZE_2 3
#define SIZE_3 4

#else
#error Unsupported Operating System, sorry.
#endif
#+END_SRC

In order to be sure that my everything works, I thought it would be a
good idea to test the program not only on a 64-bit system, but also
32-bit and 16-bit.  In order to do so this is what I did.

First I installed multilib on Linux.  It allows to use a 32-bit GCC
compiler and run 32-bit code.  After the installation it's really
easy.  The only thing that changes is the ~-m32~ option.

Here is my ~GNUmakefile~:
#+BEGIN_SRC makefile
CFLAGS=-g -O0 -Wall -fstrict-aliasing -Wstrict-aliasing -Wconversion

.PHONY: all
all: mem_test mem_test32

mem_test: mem_test.c mem.c
	gcc $(CFLAGS) mem_test.c mem.c -o mem_test

mem_test32: mem_test.c mem.c
	gcc $(CFLAGS) -m32 mem_test.c mem.c -o mem_test32

.PHONY: clean
clean:
	rm -f *.o mem_test mem_test32
#+END_SRC

The program seems to work fine on 64-bit Linux, 32-bit Linux and
32-bit Hurd.

In order to do more tests I made it so that it compiles under
OpenWatcom v2.0 C compiler.  So, using Linux I compiled 32-bit Linux,
DOS, and ArcaOS binaries.  OpenWatcom can also generate 16-bit DOS
binaries, which is interesting because it allows me to test the
program with yet another set of parameters.

So I tested in on ArcaOS, which is a 32-bit Operating System, and it
seems to work fine.  Which is interesting is that ArcaOS can also run
DOS programs.  So I tested both the 32-bit and the 16-bit binaries.
Worked very well.  It really amazes me that one single OS has so many
modes of running software, and it was so long ago...

Of course I also tested on an emulator, /qemu/, running FreeDOS.  Both
binaries worked.


* End
So, this is the end of this quick post about my little memory
allocator.  As you can see it's really simple.
